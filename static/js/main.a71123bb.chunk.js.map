{"version":3,"sources":["components/board/Board.module.css","components/header/Header.module.css","components/end-game-panel/EndGamePanel.module.css","pages/game/Game.module.css","redux/actions/action-types.js","constants.js","redux/reducers/game.js","redux/reducers/tiles.js","redux/reducers/score.js","redux/reducers/index.js","redux/actions/tiles.js","redux/actions/game.js","redux/actions/score.js","helpers.js","redux/sagas.js","redux/store.js","components/header/Header.js","components/header/index.js","components/board/Board.js","components/board/index.js","components/end-game-panel/EndGamePanel.js","components/end-game-panel/index.js","pages/game/Game.js","pages/game/index.js","index.js"],"names":["module","exports","NEW_GAME","NEW_TILE","MOVE_TILES","MERGE_TILES","GAME_STATES","IN_PROGRESS","VICTORY","GAME_OVER","IN_PROGRESS_AFTER_VICTORY","DIRECTIONS","UP","LEFT","DOWN","RIGHT","ARROWS","38","37","40","39","initialState","gameState","gameReducer","state","action","type","actions","grid","tilesMoving","tilesReducer","payload","currentScore","scoreReducer","newScore","combineReducers","game","tiles","score","newTile","moveTiles","direction","mergeTiles","updateGrid","setTilesMoving","value","newGame","gameOver","victory","keepPlaying","incrementScore","VECTOR","row","col","generateGrid","i","j","push","newGrid","vector","validMove","movementAllowed","nextPos","tileValue","result","newPosition","emptyCell","sameValueCell","unmergedCell","willMergeWith","tile","updatedTile","newMerged","newRandom","availableMoves","flatten","some","cell","forEach","generateNewTile","coords","randomValue","Math","random","id","uuid","getRandomEmptyCoords","cells","emptyCells","getEmptyCells","floor","length","addTile","map","mergePendingTiles","containsVictoryTile","filter","calculateScore","newTileSaga","newGameSaga","moveTilesSaga","mergeTilesSaga","rootSaga","sleep","ms","Promise","res","setTimeout","task","select","updatedGrid","put","takeEvery","endGame","all","sagaMiddleware","createSagaMiddleware","store","createStore","rootReducer","compose","applyMiddleware","run","Header","props","onNewGameClick","className","styles","container","title","gameInfo","scoreContainer","scoreLabel","scoreValue","newGameBtn","onClick","HeaderContainer","dispatch","useDispatch","useSelector","handleNewGame","useCallback","BoardGrid","GRID_SIZE","key","boardGridCell","boardGrid","Tiles","tilesContainer","positionStyles","transform","classes","classNames","newRandomTile","newMergedTile","tileContainer","style","Board","boardContainer","BoardContainer","sort","tile1","tile2","useEffect","window","addEventListener","handleKeyPress","removeEventListener","e","keyCode","GameOverPanel","endGamePanel","panelBtn","VictoryPanel","onKeepPlayingClick","EndGamePanel","content","EndGamePanelContainer","handleKeepPlaying","Game","showEndGamePanel","PLAYING","positionRelative","howToPlayText","boldText","viewOnGithubLink","href","target","GameContainer","onSwiped","dir","toUpperCase","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.a71123bb.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"boardContainer\":\"Board_boardContainer__1LEFg\",\"boardGrid\":\"Board_boardGrid__30AAE\",\"boardGridCell\":\"Board_boardGridCell__2cENT\",\"tilesContainer\":\"Board_tilesContainer__3TIBn\",\"tileContainer\":\"Board_tileContainer__3YcLx\",\"tile\":\"Board_tile__36kz5\",\"newRandomTile\":\"Board_newRandomTile__3aOcI\",\"newRandomTileAnimation\":\"Board_newRandomTileAnimation__1eu4J\",\"newMergedTile\":\"Board_newMergedTile__2fYCj\",\"newMergedTileAnimation\":\"Board_newMergedTileAnimation__1FEAj\",\"tile-2\":\"Board_tile-2__1868c\",\"tile-4\":\"Board_tile-4__2ZMie\",\"tile-8\":\"Board_tile-8__TQ_WY\",\"tile-16\":\"Board_tile-16__h7mTZ\",\"tile-32\":\"Board_tile-32__3Ge3d\",\"tile-64\":\"Board_tile-64__1QBuo\",\"tile-128\":\"Board_tile-128__fVeou\",\"tile-256\":\"Board_tile-256__1HYOa\",\"tile-512\":\"Board_tile-512__1YoSF\",\"tile-1024\":\"Board_tile-1024__3qOp-\",\"tile-2048\":\"Board_tile-2048__3LhJo\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"Header_container__27QFJ\",\"title\":\"Header_title__3_fub\",\"gameInfo\":\"Header_gameInfo__3aUvJ\",\"scoreContainer\":\"Header_scoreContainer__3bq5H\",\"scoreLabel\":\"Header_scoreLabel__3uraT\",\"scoreValue\":\"Header_scoreValue__2HLNR\",\"newGameBtn\":\"Header_newGameBtn__1c5MY\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"EndGamePanel_container__F2q-c\",\"endGamePanel\":\"EndGamePanel_endGamePanel__1vMAp\",\"fadeInAnimation\":\"EndGamePanel_fadeInAnimation__3GGIs\",\"panelBtn\":\"EndGamePanel_panelBtn__PTD2G\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"Game_container__39SqM\",\"howToPlayText\":\"Game_howToPlayText__6SN9W\",\"viewOnGithubLink\":\"Game_viewOnGithubLink__2drxN\",\"positionRelative\":\"Game_positionRelative__29WxI\",\"boldText\":\"Game_boldText__1PbJY\"};","export const NEW_GAME = 'NEW_GAME';\nexport const VICTORY = 'VICTORY';\nexport const GAME_OVER = 'GAME_OVER';\nexport const KEEP_PLAYING = 'KEEP_PLAYING';\n\nexport const RESET_SCORE = 'RESET_SCORE';\nexport const INCREMENT_SCORE = 'INCREMENT_SCORE';\n\nexport const NEW_TILE = 'NEW_TILE';\nexport const MOVE_TILES = 'MOVE_TILES';\nexport const MERGE_TILES = 'MERGE_TILES';\nexport const UPDATE_GRID = 'UPDATE_GRID';\nexport const SET_TILES_MOVING = 'SET_TILES_MOVING';\n","// Tile needed to win the game\nexport const VICTORY_TILE = 2048;\n\n// Game states\nexport const GAME_STATES = {\n  IN_PROGRESS: 'IN_PROGRESS',\n  VICTORY: 'VICTORY',\n  GAME_OVER: 'GAME_OVER',\n  IN_PROGRESS_AFTER_VICTORY: 'IN_PROGRESS_AFTER_VICTORY',\n};\n\n// Board grid size\nexport const GRID_SIZE = 4;\n\n// Directions\nexport const DIRECTIONS = {\n  UP: 'UP',\n  LEFT: 'LEFT',\n  DOWN: 'DOWN',\n  RIGHT: 'RIGHT',\n};\n\n// Keyboard arrows codes\nexport const ARROWS = {\n  38: DIRECTIONS.UP,\n  37: DIRECTIONS.LEFT,\n  40: DIRECTIONS.DOWN,\n  39: DIRECTIONS.RIGHT,\n};\n","import * as actions from '../actions/action-types';\nimport { GAME_STATES } from '../../constants';\n\nconst initialState = {\n  gameState: GAME_STATES.IN_PROGRESS,\n};\n\nconst gameReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case actions.NEW_GAME: {\n      return { ...state, gameState: GAME_STATES.IN_PROGRESS };\n    }\n    case actions.KEEP_PLAYING: {\n      return { ...state, gameState: GAME_STATES.IN_PROGRESS_AFTER_VICTORY };\n    }\n    case actions.GAME_OVER: {\n      return { ...state, gameState: GAME_STATES.GAME_OVER };\n    }\n    case actions.VICTORY: {\n      return { ...state, gameState: GAME_STATES.VICTORY };\n    }\n    default:\n      return state;\n  }\n};\n\nexport default gameReducer;\n","import * as actions from '../actions/action-types';\n\nconst initialState = {\n  grid: [],\n  tilesMoving: false,\n};\n\nconst tilesReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case actions.SET_TILES_MOVING: {\n      return { ...state, tilesMoving: action.payload };\n    }\n    case actions.UPDATE_GRID: {\n      return { ...state, grid: action.payload };\n    }\n    default:\n      return state;\n  }\n};\n\nexport default tilesReducer;\n","import * as actions from '../actions/action-types';\n\nconst initialState = {\n  currentScore: 0,\n};\n\nconst scoreReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case actions.NEW_GAME: {\n      return { ...state, currentScore: 0 };\n    }\n    case actions.INCREMENT_SCORE: {\n      const newScore = state.currentScore + action.payload;\n      return { ...state, currentScore: newScore };\n    }\n    default:\n      return state;\n  }\n};\n\nexport default scoreReducer;\n","import { combineReducers } from 'redux';\n\nimport gameReducer from './game';\nimport tilesReducer from './tiles';\nimport scoreReducer from './score';\n\nexport default combineReducers({\n  game: gameReducer,\n  tiles: tilesReducer,\n  score: scoreReducer,\n});\n","import * as actions from './action-types';\n\n/**\n * Creates a new tile with a random position\n */\nexport const newTile = () => ({\n  type: actions.NEW_TILE,\n});\n\n/**\n * Moves all tiles to a given direction\n *\n * @param {String} direction UP, DOWN, LEFT or RIGHT\n */\nexport const moveTiles = direction => ({\n  type: actions.MOVE_TILES,\n  payload: direction,\n});\n\n/**\n * Merges the tiles in the same cell\n */\nexport const mergeTiles = () => ({\n  type: actions.MERGE_TILES,\n});\n\n/**\n * Updates board grid\n *\n * @param {Array} grid\n */\nexport const updateGrid = grid => ({\n  type: actions.UPDATE_GRID,\n  payload: grid,\n});\n\n/**\n * Sets if tiles are moving or not\n *\n * @param {Boolean} value\n */\nexport const setTilesMoving = value => ({\n  type: actions.SET_TILES_MOVING,\n  payload: value,\n});\n","import * as actions from './action-types';\n\n/**\n * Starts a new game\n */\nexport const newGame = () => ({\n  type: actions.NEW_GAME,\n});\n\n/**\n * Ends the game when the player lose\n */\nexport const gameOver = () => ({\n  type: actions.GAME_OVER,\n});\n\n/**\n * Ends the game when the player win\n */\nexport const victory = () => ({\n  type: actions.VICTORY,\n});\n\n/**\n * Allows player to keep playing after victory\n */\nexport const keepPlaying = () => ({\n  type: actions.KEEP_PLAYING,\n});\n","import * as actions from './action-types';\n\n/**\n * Increments the current score\n *\n * @param {Number} value value to be incremented\n */\nexport const incrementScore = value => ({\n  type: actions.INCREMENT_SCORE,\n  payload: value,\n});\n\n/**\n * Sets the current score to 0 (zero)\n */\nexport const resetScore = () => ({\n  type: actions.RESET_SCORE,\n});\n","import { flatten } from 'lodash';\nimport uuid from 'uuid/v4';\n\nimport { GRID_SIZE, DIRECTIONS, GAME_STATES, VICTORY_TILE } from './constants';\n\n// Movement vector direction\nconst VECTOR = {\n  UP: { row: -1, col: 0 },\n  DOWN: { row: 1, col: 0 },\n  LEFT: { row: 0, col: -1 },\n  RIGHT: { row: 0, col: 1 },\n};\n\n/**\n * Generates a grid with empty cells\n */\nexport const generateGrid = () => {\n  const grid = [];\n  for (let i = 0; i < GRID_SIZE; i += 1) {\n    const row = [];\n    for (let j = 0; j < GRID_SIZE; j += 1) {\n      row.push(null);\n    }\n    grid.push(row);\n  }\n\n  return grid;\n};\n\n/**\n * Returns a grid with moved tiles\n *\n * @param {Array} grid\n * @param {Object} direction\n * @returns {Array}\n */\nexport const moveTiles = (grid, direction) => {\n  const newGrid = generateGrid();\n  const vector = VECTOR[direction];\n  let validMove = false;\n\n  const movementAllowed = (nextPos, tileValue) => {\n    let result = true;\n\n    result = result && nextPos.row >= 0;\n    result = result && nextPos.col >= 0;\n    result = result && nextPos.row < GRID_SIZE;\n    result = result && nextPos.col < GRID_SIZE;\n\n    if (result) {\n      const newPosition = newGrid[nextPos.row][nextPos.col];\n      const emptyCell = newPosition === null;\n      const sameValueCell = newPosition && newPosition.value === tileValue;\n      const unmergedCell = newPosition && !newPosition.willMergeWith;\n      result = (result && emptyCell) || (sameValueCell && unmergedCell);\n    }\n\n    return result;\n  };\n\n  for (let i = 0; i < GRID_SIZE; i += 1) {\n    for (let j = 0; j < GRID_SIZE; j += 1) {\n      let row = i;\n      let col = j;\n\n      // Reverse row iterate tiles from bottom to top\n      if (direction === DIRECTIONS.DOWN) row = GRID_SIZE - i - 1;\n\n      // Reverse col iterate tiles from right to left\n      if (direction === DIRECTIONS.RIGHT) col = GRID_SIZE - j - 1;\n\n      const tile = grid[row][col];\n\n      if (tile !== null) {\n        const updatedTile = { ...tile };\n        const nextPos = {\n          row: tile.row + vector.row,\n          col: tile.col + vector.col,\n        };\n\n        updatedTile.newMerged = false;\n        updatedTile.newRandom = false;\n\n        while (movementAllowed(nextPos, updatedTile.value)) {\n          updatedTile.row = nextPos.row;\n          updatedTile.col = nextPos.col;\n\n          nextPos.row += vector.row;\n          nextPos.col += vector.col;\n\n          if (updatedTile.row !== tile.row || updatedTile.col !== tile.col) {\n            validMove = true;\n          }\n        }\n\n        if (newGrid[updatedTile.row][updatedTile.col] !== null) {\n          newGrid[updatedTile.row][updatedTile.col].willMergeWith = updatedTile;\n        } else {\n          newGrid[updatedTile.row][updatedTile.col] = updatedTile;\n        }\n      }\n    }\n  }\n  return { newGrid, validMove };\n};\n\n/**\n * Returns if there are available moves or not\n *\n * @param {Array} grid\n * @returns {Boolean}\n */\nexport const availableMoves = grid => {\n  // Checks if there are empty cells\n  if (flatten(grid).some(cell => cell === null)) return true;\n\n  // Checks if there are adajacent cells with the same value\n  let result = false;\n  flatten(grid).forEach(tile => {\n    const { row, col, value } = tile;\n    if (row + 1 < GRID_SIZE) {\n      if (grid[row + 1][col].value === value) result = true;\n    }\n    if (col + 1 < GRID_SIZE) {\n      if (grid[row][col + 1].value === value) result = true;\n    }\n  });\n  return result;\n};\n\n/**\n * Creates a new tile object\n *\n * @param {Array} coords\n * @param {Array} value\n * @returns {Object}\n */\nexport const generateNewTile = (coords, value = null) => {\n  const randomValue = Math.random() > 0.9 ? 4 : 2;\n  const newMerged = !!value;\n  const newRandom = !value;\n\n  return {\n    id: uuid(),\n    value: value ? value : randomValue,\n    row: coords[0],\n    col: coords[1],\n    newMerged: newMerged,\n    newRandom: newRandom,\n    willMergeWith: null,\n  };\n};\n\n/**\n * Returns the coordinates of all empty cells in the grid\n *\n * @param {Array} cells\n * @returns {Array}\n */\nexport const getEmptyCells = cells => {\n  const emptyCells = [];\n\n  cells.forEach((row, i) => {\n    row.forEach((col, j) => {\n      if (!col) {\n        emptyCells.push([i, j]);\n      }\n    });\n  });\n  return emptyCells;\n};\n\n/**\n * Returns the coordinates of a empty random cell\n *\n * @param {Array} cells List of empty cells\n * @returns {Array}\n */\nexport const getRandomEmptyCoords = cells => {\n  const emptyCells = getEmptyCells(cells);\n  return emptyCells[Math.floor(Math.random() * emptyCells.length)];\n};\n\n/**\n * Returns a new grid with the added tile\n *\n * @param {Array} grid\n * @param {Object} tile\n * @returns {Array}\n */\nexport const addTile = (grid, tile) => {\n  const updatedGrid = grid.map((row, i) => {\n    if (i !== tile.row) {\n      return row;\n    } else {\n      return row.map((col, j) => {\n        if (j !== tile.col) {\n          return col;\n        } else {\n          return tile;\n        }\n      });\n    }\n  });\n  return updatedGrid;\n};\n\n/**\n * Returns a new grid with the new merged tiles from the last move\n *\n * @param {Array} grid\n * @returns {Array}\n */\nexport const mergePendingTiles = grid => {\n  const updatedGrid = grid.map(row => {\n    return row.map(tile => {\n      if (tile && tile.willMergeWith) {\n        const coords = [tile.row, tile.col];\n        const value = tile.value * 2;\n        return generateNewTile(coords, value);\n      } else {\n        return tile;\n      }\n    });\n  });\n  return updatedGrid;\n};\n\n/**\n * Returns if the victory tile is present in the grid\n *\n * @param {String} gameState\n * @param {Array} grid\n * @returns {Boolean}\n */\nexport const containsVictoryTile = (gameState, grid) => {\n  if (gameState === GAME_STATES.IN_PROGRESS_AFTER_VICTORY) return;\n  return flatten(grid)\n    .filter(cell => cell)\n    .some(cell => cell.value === VICTORY_TILE);\n};\n\n/**\n * Calculates the score of the last move\n *\n * @param {Array} grid\n * @returns {Number}\n */\nexport const calculateScore = grid => {\n  const tiles = flatten(grid).filter(cell => cell !== null);\n  let value = 0;\n\n  for (const tile of tiles) {\n    if (tile.newMerged) {\n      value += tile.value;\n    }\n  }\n  return value;\n};\n","import { put, takeEvery, all, select } from 'redux-saga/effects';\n\nimport { newTile, mergeTiles, updateGrid, setTilesMoving } from './actions/tiles';\nimport { gameOver, victory } from './actions/game';\nimport { incrementScore } from './actions/score';\nimport * as actions from './actions/action-types';\nimport { GAME_STATES } from '../constants';\nimport {\n  generateGrid,\n  moveTiles,\n  availableMoves,\n  generateNewTile,\n  getRandomEmptyCoords,\n  addTile,\n  mergePendingTiles,\n  containsVictoryTile,\n  calculateScore,\n} from '../helpers';\n\nconst sleep = ms => new Promise(res => setTimeout(res, ms));\n\nfunction* newTileSaga() {\n  function* task() {\n    const grid = yield select(state => state.tiles.grid);\n    if (grid.length) {\n      const coords = getRandomEmptyCoords(grid);\n      const tile = generateNewTile(coords);\n      const updatedGrid = addTile(grid, tile);\n      yield put(updateGrid(updatedGrid));\n    }\n  }\n  yield takeEvery(actions.NEW_TILE, task);\n}\n\nfunction* newGameSaga() {\n  function* task() {\n    const grid = generateGrid();\n    yield put(updateGrid(grid));\n    yield put(newTile());\n    yield put(newTile());\n  }\n  yield takeEvery(actions.NEW_GAME, task);\n}\n\nfunction* moveTilesSaga() {\n  function* task(action) {\n    const { grid, tilesMoving } = yield select(state => state.tiles);\n    const gameState = yield select(state => state.game.gameState);\n    const { newGrid, validMove } = moveTiles(grid, action.payload);\n    const endGame = gameState === GAME_STATES.VICTORY || gameState === GAME_STATES.GAME_OVER;\n\n    if (tilesMoving || endGame) return;\n\n    if (!availableMoves(newGrid)) {\n      yield put(gameOver());\n    } else if (validMove) {\n      yield put(setTilesMoving(true));\n      yield put(updateGrid(newGrid));\n\n      yield sleep(150);\n      yield put(setTilesMoving(false));\n      yield put(mergeTiles());\n\n      yield put(newTile());\n    }\n  }\n  yield takeEvery(actions.MOVE_TILES, task);\n}\n\nfunction* mergeTilesSaga() {\n  function* task() {\n    const gameState = yield select(state => state.game.gameState);\n    const grid = yield select(state => state.tiles.grid);\n    const updatedGrid = mergePendingTiles(grid);\n    const score = calculateScore(updatedGrid);\n\n    yield put(updateGrid(updatedGrid));\n    yield put(incrementScore(score));\n\n    if (containsVictoryTile(gameState, grid)) {\n      yield put(victory());\n    }\n  }\n  yield takeEvery(actions.MERGE_TILES, task);\n}\n\nexport default function* rootSaga() {\n  yield all([newGameSaga(), moveTilesSaga(), mergeTilesSaga(), newTileSaga()]);\n}\n","import { createStore, applyMiddleware, compose } from 'redux';\nimport createSagaMiddleware from 'redux-saga';\n\nimport rootReducer from './reducers';\nimport rootSaga from './sagas';\n\nconst sagaMiddleware = createSagaMiddleware();\nconst store = createStore(\n  rootReducer,\n  compose(\n    applyMiddleware(sagaMiddleware)\n    // window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n  )\n);\nsagaMiddleware.run(rootSaga);\n\nexport default store;\n","import React from 'react';\n\nimport PropTypes from 'prop-types';\n\nimport styles from './Header.module.css';\n\nconst propTypes = {\n  score: PropTypes.number.isRequired,\n  onNewGameClick: PropTypes.func.isRequired,\n};\n\nfunction Header(props) {\n  const { score, onNewGameClick } = props;\n\n  return (\n    <div className={styles.container}>\n      <h1 className={styles.title}>2048</h1>\n      <div className={styles.gameInfo}>\n        <div className={styles.scoreContainer}>\n          <div className={styles.scoreLabel}>Score</div>\n          <div className={styles.scoreValue}>{score}</div>\n        </div>\n        <button className={styles.newGameBtn} onClick={onNewGameClick}>\n          New Game\n        </button>\n      </div>\n    </div>\n  );\n}\n\nHeader.propTypes = propTypes;\nexport default Header;\n","import React, { useCallback } from 'react';\n\nimport { useSelector, useDispatch } from 'react-redux';\n\nimport { newGame } from '../../redux/actions/game';\nimport Header from './Header';\n\nfunction HeaderContainer() {\n  const dispatch = useDispatch();\n  const score = useSelector(state => state.score.currentScore);\n\n  const handleNewGame = useCallback(() => {\n    dispatch(newGame());\n  }, [dispatch]);\n\n  return <Header score={score} onNewGameClick={handleNewGame} />;\n}\n\nexport default HeaderContainer;\n","import React from 'react';\n\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\n\nimport { GRID_SIZE } from '../../constants';\nimport styles from './Board.module.css';\n\nconst propTypes = {\n  tiles: PropTypes.array.isRequired,\n};\n\nconst BoardGrid = () => {\n  const cells = [];\n\n  for (let i = 0; i < GRID_SIZE * GRID_SIZE; i += 1) {\n    cells.push(<div key={i} className={styles.boardGridCell}></div>);\n  }\n  return <div className={styles.boardGrid}>{cells}</div>;\n};\n\nconst Tiles = props => {\n  const tiles = props.tiles;\n\n  return (\n    <div className={styles.tilesContainer}>\n      {tiles.map(tile => {\n        const positionStyles = {\n          transform: `translate(${tile.col * (75 + 10)}px, ${tile.row * (75 + 10)}px)`,\n        };\n\n        let classes = classNames(styles.tile, {\n          [styles.newRandomTile]: tile.newRandom,\n          [styles.newMergedTile]: tile.newMerged,\n          [styles[`tile-${tile.value}`]]: true,\n        });\n\n        return (\n          <div key={tile.id} className={styles.tileContainer} style={positionStyles}>\n            <div className={classes}>{tile.value}</div>\n          </div>\n        );\n      })}\n    </div>\n  );\n};\n\nfunction Board(props) {\n  const tiles = props.tiles;\n\n  return (\n    <div className={styles.boardContainer}>\n      <BoardGrid />\n      <Tiles tiles={tiles} />\n    </div>\n  );\n}\n\nBoard.propTypes = propTypes;\nexport default Board;\n","import React, { useEffect } from 'react';\n\nimport { useSelector, useDispatch } from 'react-redux';\nimport { flatten } from 'lodash';\n\nimport { moveTiles } from '../../redux/actions/tiles';\nimport { ARROWS } from '../../constants';\nimport Board from './Board';\n\nconst BoardContainer = () => {\n  const dispatch = useDispatch();\n  const tiles = useSelector(state => {\n    const tiles = [];\n    flatten(state.tiles.grid).forEach(tile => {\n      if (tile) {\n        tiles.push(tile);\n\n        if (tile.willMergeWith) {\n          tiles.push(tile.willMergeWith);\n        }\n      }\n    });\n\n    return tiles.sort((tile1, tile2) => (tile1.id > tile2.id ? 1 : -1));\n  });\n\n  // Add keypress event listener\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyPress);\n    return () => {\n      window.removeEventListener('keydown', handleKeyPress);\n    };\n  });\n\n  const handleKeyPress = e => {\n    const direction = ARROWS[e.keyCode];\n\n    if (direction) {\n      dispatch(moveTiles(direction));\n    }\n  };\n\n  return <Board tiles={tiles} />;\n};\n\nexport default BoardContainer;\n","import React from 'react';\n\nimport PropTypes from 'prop-types';\n\nimport { GAME_STATES } from '../../constants';\nimport styles from './EndGamePanel.module.css';\n\nconst propTypes = {\n  gameState: PropTypes.string.isRequired,\n  onNewGameClick: PropTypes.func.isRequired,\n  onKeepPlayingClick: PropTypes.func.isRequired,\n};\n\nconst GameOverPanel = props => {\n  return (\n    <div className={styles.endGamePanel}>\n      <h1>GAME OVER!</h1>\n      <button className={styles.panelBtn} onClick={props.onNewGameClick}>\n        Try Again\n      </button>\n    </div>\n  );\n};\n\nconst VictoryPanel = props => {\n  return (\n    <div className={styles.endGamePanel}>\n      <h1>YOU WIN!</h1>\n      <div>\n        <button className={styles.panelBtn} onClick={props.onKeepPlayingClick}>\n          Keep Playing\n        </button>\n        <button className={styles.panelBtn} onClick={props.onNewGameClick}>\n          Try Again\n        </button>\n      </div>\n    </div>\n  );\n};\n\nfunction EndGamePanel(props) {\n  const { onNewGameClick, onKeepPlayingClick } = props;\n  let content = null;\n\n  if (props.gameState === GAME_STATES.GAME_OVER) {\n    content = <GameOverPanel onNewGameClick={onNewGameClick} />;\n  } else if (props.gameState === GAME_STATES.VICTORY) {\n    content = <VictoryPanel onNewGameClick={onNewGameClick} onKeepPlayingClick={onKeepPlayingClick} />;\n  }\n\n  return <div className={styles.container}>{content}</div>;\n}\n\nEndGamePanel.propTypes = propTypes;\nexport default EndGamePanel;\n","import React, { useCallback } from 'react';\n\nimport { useSelector, useDispatch } from 'react-redux';\n\nimport { newGame, keepPlaying } from '../../redux/actions/game';\nimport EndGamePanel from './EndGamePanel';\n\nfunction EndGamePanelContainer() {\n  const dispatch = useDispatch();\n  const gameState = useSelector(state => state.game.gameState);\n\n  const handleNewGame = useCallback(() => {\n    dispatch(newGame());\n  }, [dispatch]);\n\n  const handleKeepPlaying = useCallback(() => {\n    dispatch(keepPlaying());\n  }, [dispatch]);\n\n  return <EndGamePanel gameState={gameState} onNewGameClick={handleNewGame} onKeepPlayingClick={handleKeepPlaying} />;\n}\n\nexport default EndGamePanelContainer;\n","import React from 'react';\n\nimport PropTypes from 'prop-types';\n\nimport Header from '../../components/header';\nimport Board from '../../components/board';\nimport EndGamePanel from '../../components/end-game-panel';\nimport { GAME_STATES } from '../../constants';\nimport styles from './Game.module.css';\n\nconst propTypes = {\n  gameState: PropTypes.string.isRequired,\n};\n\nfunction Game(props) {\n  const showEndGamePanel = props.gameState !== GAME_STATES.PLAYING;\n\n  return (\n    <div className={styles.container}>\n      <Header />\n\n      <div className={styles.positionRelative}>\n        <Board />\n        {showEndGamePanel && <EndGamePanel />}\n      </div>\n\n      <p className={styles.howToPlayText}>\n        <span className={styles.boldText}>HOW TO PLAY</span>: Use your arrow keys or swipe to move the tiles. When two\n        tiles with the same number touch, they merge into one!\n      </p>\n\n      <div className={styles.viewOnGithubLink}>\n        <a href=\"https://github.com/rbika/2048\" target=\"_blank\">\n          View on Github\n        </a>\n      </div>\n    </div>\n  );\n}\n\nGame.propTypes = propTypes;\nexport default Game;\n","import React, { useEffect } from 'react';\n\nimport { useSelector, useDispatch } from 'react-redux';\nimport { Swipeable } from 'react-swipeable';\n\nimport { newGame } from '../../redux/actions/game';\nimport { moveTiles } from '../../redux/actions/tiles';\nimport { DIRECTIONS } from '../../constants';\nimport Game from './Game';\n\nfunction GameContainer() {\n  const gameState = useSelector(state => state.game.gameState);\n  const dispatch = useDispatch();\n\n  // Starts a new game\n  useEffect(() => {\n    dispatch(newGame());\n  }, []);\n\n  const handleSwipe = e => {\n    const direction = DIRECTIONS[e.dir.toUpperCase()];\n\n    if (direction) {\n      dispatch(moveTiles(direction));\n    }\n  };\n\n  return (\n    <Swipeable onSwiped={handleSwipe}>\n      <Game gameState={gameState} />\n    </Swipeable>\n  );\n}\n\nexport default GameContainer;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { Provider } from 'react-redux';\nimport store from './redux/store';\n\nimport Game from './pages/game';\nimport './index.css';\n\nReactDOM.render(\n  <Provider store={store}>\n    <React.StrictMode>\n      <Game />\n    </React.StrictMode>\n  </Provider>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}